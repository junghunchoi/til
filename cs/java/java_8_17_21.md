Java 8 주요 기능
1. Stream API
   답변 예시:
   "기존 프로젝트에서 사용자 주문 데이터를 처리할 때 Stream API를 적극 활용했습니다. 예를 들어, 최근 3개월 주문 중 특정 카테고리별 매출 합계를 구하는 로직을 작성할 때:
   ```java 
       // 기존 for-loop 방식 (10줄 이상)
       Map<String, BigDecimal> categorySum = new HashMap<>();
       for (Order order : orders) {
       if (order.getOrderDate().isAfter(threeMonthsAgo)) {
       String category = order.getProduct().getCategory();
       BigDecimal amount = categorySum.getOrDefault(category, BigDecimal.ZERO);
       categorySum.put(category, amount.add(order.getAmount()));
       }
       }
       
       // Stream 활용 (간결하고 가독성 향상)
       Map<String, BigDecimal> categorySum = orders.stream()
       .filter(order -> order.getOrderDate().isAfter(threeMonthsAgo))
       .collect(Collectors.groupingBy(
       order -> order.getProduct().getCategory(),
       Collectors.reducing(BigDecimal.ZERO, Order::getAmount, BigDecimal::add)
       ));
       특히 복잡한 비즈니스 로직에서 filter, map, collect의 조합으로 코드의 가독성과 유지보수성이 크게 향상되었습니다."
       (꼬리물기 질문: Stream의 성능 이슈나 주의점은 없었나요? parallelStream은 언제 사용하시나요?)
    ```
   2. Optional
   답변 예시:
   "NPE(NullPointerException) 방지를 위해 Optional을 도입했습니다. 특히 사용자 프로필 조회 API에서:
      ```
      java// 기존 방식
        public UserProfile getUserProfile(Long userId) {
        User user = userRepository.findById(userId);
        if (user != null && user.getProfile() != null) {
        return user.getProfile();
        }
        return getDefaultProfile();
        }
      
        // Optional 활용
        public UserProfile getUserProfile(Long userId) {
           return userRepository.findById(userId)
           .map(User::getProfile)
           .orElse(getDefaultProfile());
        }
      ```
팀 내 코드 리뷰에서 null 체크 관련 이슈가 80% 이상 줄어들었고, 코드의 의도가 더 명확해졌습니다."
(꼬리물기 질문: Optional을 남용하면 안 되는 경우가 있다고 하는데, 어떤 가이드라인을 따르시나요?)
3. Lambda Expression
   답변 예시:
   "비동기 처리와 이벤트 처리에서 Lambda를 활용했습니다. 주문 완료 후 다양한 후처리 작업을 처리할 때:
   java// 기존 Anonymous Inner Class
   orderService.processOrder(order, new OrderCallback() {
   @Override
   public void onSuccess(Order processedOrder) {
   emailService.sendConfirmation(processedOrder);
   inventoryService.updateStock(processedOrder);
   analyticsService.trackOrder(processedOrder);
   }
   });

// Lambda 활용
orderService.processOrder(order, processedOrder -> {
emailService.sendConfirmation(processedOrder);
inventoryService.updateStock(processedOrder);
analyticsService.trackOrder(processedOrder);
});
코드가 간결해지고 함수형 프로그래밍 패러다임을 적용해 부작용을 줄일 수 있었습니다."
(꼬리물기 질문: Lambda와 Method Reference는 언제 구분해서 사용하시나요?)
Java 17 주요 기능
1. Records
   답변 예시:
   "DTO(Data Transfer Object)와 Value Object를 구현할 때 Records를 적극 활용했습니다. API 응답 객체나 설정 정보를 담는 불변 객체에 특히 유용했습니다:
   java// 기존 방식 (30줄 이상의 boilerplate 코드)
   public class OrderResponse {
   private final Long orderId;
   private final String customerName;
   private final BigDecimal amount;

   // constructor, getters, equals, hashCode, toString...
   }

// Records 활용 (1줄로 완성)
public record OrderResponse(Long orderId, String customerName, BigDecimal amount) {
// 필요시 custom validation만 추가
public OrderResponse {
if (amount.compareTo(BigDecimal.ZERO) < 0) {
throw new IllegalArgumentException("Amount cannot be negative");
}
}
}
개발 생산성이 크게 향상되었고, 불변성이 보장되어 동시성 이슈도 줄어들었습니다."
(꼬리물기 질문: Records를 JPA Entity로 사용할 수 있나요? 어떤 제약사항이 있나요?)
2. Pattern Matching for instanceof
   답변 예시:
   "다양한 타입의 결제 수단을 처리하는 로직에서 Pattern Matching을 활용했습니다:
   java// 기존 방식
   public BigDecimal calculateFee(PaymentMethod payment) {
   if (payment instanceof CreditCard) {
   CreditCard card = (CreditCard) payment;
   return card.getAmount().multiply(new BigDecimal("0.03"));
   } else if (payment instanceof BankTransfer) {
   BankTransfer transfer = (BankTransfer) payment;
   return transfer.getAmount().multiply(new BigDecimal("0.01"));
   }
   return BigDecimal.ZERO;
   }

// Pattern Matching 활용
public BigDecimal calculateFee(PaymentMethod payment) {
if (payment instanceof CreditCard card) {
return card.getAmount().multiply(new BigDecimal("0.03"));
} else if (payment instanceof BankTransfer transfer) {
return transfer.getAmount().multiply(new BigDecimal("0.01"));
}
return BigDecimal.ZERO;
}
타입 캐스팅 관련 실수가 줄어들고 코드 가독성이 향상되었습니다."
(꼬리물기 질문: Switch Expression과 함께 사용하면 더 효과적일 것 같은데, 실제로 적용해보신 적이 있나요?)
3. Sealed Classes
   답변 예시:
   "도메인 모델링에서 상태 패턴을 구현할 때 Sealed Classes를 활용했습니다. 주문 상태 관리에서:
   javapublic sealed class OrderStatus
   permits Pending, Processing, Shipped, Delivered, Cancelled {

   public abstract boolean canCancel();
   public abstract BigDecimal calculateRefund();
   }

public final class Pending extends OrderStatus {
@Override
public boolean canCancel() { return true; }

    @Override
    public BigDecimal calculateRefund() { return fullAmount; }
}

public final class Processing extends OrderStatus {
@Override
public boolean canCancel() { return true; }

    @Override
    public BigDecimal calculateRefund() { return fullAmount.multiply(new BigDecimal("0.9")); }
}
컴파일 타임에 모든 상태 케이스를 검증할 수 있어 런타임 에러를 방지할 수 있었습니다."
(꼬리물기 질문: Enum과 Sealed Class의 차이점은 무엇이고, 언제 각각을 사용하는 것이 좋을까요?)
Java 21 주요 기능
1. Virtual Threads (Project Loom)
   답변 예시:
   "높은 동시성이 필요한 API 서버에서 Virtual Thread를 도입했습니다. 기존 Thread Pool 기반 서버에서 발생하던 Thread 부족 문제를 해결했습니다:
   java// 기존 Platform Thread 방식
   @RestController
   public class OrderController {
   @Async
   @GetMapping("/orders/{id}")
   public CompletableFuture<Order> getOrder(@PathVariable Long id) {
   return CompletableFuture.supplyAsync(() -> {
   // 외부 API 호출, DB 조회 등 I/O 작업
   return orderService.findById(id);
   });
   }
   }

// Virtual Thread 활용
@RestController
public class OrderController {
@GetMapping("/orders/{id}")
public Order getOrder(@PathVariable Long id) {
// Virtual Thread에서 동기적으로 처리
return orderService.findById(id);
}
}
10,000개 동시 요청 처리 시 메모리 사용량이 1/10로 줄어들었고, 코드가 더 직관적이 되었습니다."
(꼬리물기 질문: Virtual Thread 사용 시 주의해야 할 점이나 기존 코드에서 마이그레이션할 때 고려사항이 있나요?)
2. Pattern Matching for switch
   답변 예시:
   "복잡한 비즈니스 로직 분기 처리에서 Pattern Matching for switch를 활용했습니다:
   java// 기존 방식
   public String processNotification(Notification notification) {
   if (notification instanceof EmailNotification) {
   EmailNotification email = (EmailNotification) notification;
   if (email.getPriority() == Priority.HIGH) {
   return "즉시 발송: " + email.getContent();
   } else {
   return "일반 발송: " + email.getContent();
   }
   } else if (notification instanceof SMSNotification) {
   SMSNotification sms = (SMSNotification) notification;
   return "SMS 발송: " + sms.getMessage();
   }
   return "알 수 없는 알림";
   }

// Pattern Matching for switch 활용
public String processNotification(Notification notification) {
return switch (notification) {
case EmailNotification(var content, Priority.HIGH) ->
"즉시 발송: " + content;
case EmailNotification(var content, var priority) ->
"일반 발송: " + content;
case SMSNotification(var message) ->
"SMS 발송: " + message;
default -> "알 수 없는 알림";
};
}
복잡한 분기 로직이 더 명확하고 안전하게 처리되었습니다."
(꼬리물기 질문: Exhaustiveness 체크가 어떻게 작동하나요? 새로운 케이스를 추가할 때 컴파일러가 어떻게 도움을 주나요?)
3. String Templates (Preview)
   답변 예시:
   "로그 메시지나 SQL 쿼리 생성에서 String Templates를 실험적으로 적용해봤습니다:
   java// 기존 방식
   String logMessage = String.format(
   "User %s attempted to access resource %s at %s with result: %s",
   user.getName(), resource.getPath(), timestamp, result
   );

// String Templates 활용
String logMessage = STR."""
User \{user.getName()} attempted to access resource \{resource.getPath()}
at \{timestamp} with result: \{result}
""";
가독성이 향상되고 타입 안전성이 보장되어 런타임 에러를 줄일 수 있었습니다."
(꼬리물기 질문: String Templates의 보안 이슈는 없나요? SQL Injection 같은 문제는 어떻게 방지하나요?)
버전 마이그레이션 경험
답변 예시:
"Java 8에서 17로 마이그레이션 프로젝트를 주도했습니다. 주요 작업 내용은:

호환성 검증: jdeps 도구로 deprecated API 사용 현황 파악
성능 개선: G1GC 기본 설정으로 GC 성능 20% 향상
코드 개선: var 키워드 도입으로 코드 가독성 향상
테스트 보강: 새로운 기능 도입 전 충분한 테스트 코드 작성

마이그레이션 후 애플리케이션 시작 시간이 30% 단축되고, 메모리 사용량도 15% 감소했습니다."
(꼬리물기 질문: 마이그레이션 과정에서 가장 어려웠던 점은 무엇이었나요? 팀원들의 새로운 기능 학습은 어떻게 진행하셨나요?)