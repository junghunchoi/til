# 팩토리 패턴 (Factory Pattern)

## 개념
팩토리 패턴은 객체 생성을 전담하는 별도의 클래스를 두어 객체 생성의 복잡성을 숨기고, 
생성되는 객체의 타입을 결정하는 로직을 캡슐화하는 생성 패턴입니다.

## 언제 사용하면 효과적인가?
- 객체 생성 로직이 복잡하거나 조건에 따라 다른 타입의 객체를 생성해야 할 때

## 주의해야 할 점
- 단순한 객체 생성에는 오버엔지니어링이 될 수 있음
- 새로운 제품 타입을 추가할 때마다 팩토리 클래스를 수정해야 함

## 자바 예시 코드

### 1. Simple Factory Pattern
```java
// 제품 인터페이스
interface Vehicle {
    void start();
    void stop();
}

// 구체적인 제품들
class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("자동차 시동을 걸었습니다.");
    }
    
    @Override
    public void stop() {
        System.out.println("자동차를 정지했습니다.");
    }
}

class Motorcycle implements Vehicle {
    @Override
    public void start() {
        System.out.println("오토바이 시동을 걸었습니다.");
    }
    
    @Override
    public void stop() {
        System.out.println("오토바이를 정지했습니다.");
    }
}

class Truck implements Vehicle {
    @Override
    public void start() {
        System.out.println("트럭 시동을 걸었습니다.");
    }
    
    @Override
    public void stop() {
        System.out.println("트럭을 정지했습니다.");
    }
}

// 팩토리 클래스
class VehicleFactory {
    public static Vehicle createVehicle(String type) {
        return switch (type.toLowerCase()) {
            case "car" -> new Car();
            case "motorcycle" -> new Motorcycle();
            case "truck" -> new Truck();
            default -> throw new IllegalArgumentException("알 수 없는 차량 타입: " + type);
        };
    }
}

// 클라이언트 코드
public class FactoryPatternExample {
    public static void main(String[] args) {
        Vehicle car = VehicleFactory.createVehicle("car");
        car.start();
        car.stop();
        
        Vehicle motorcycle = VehicleFactory.createVehicle("motorcycle");
        motorcycle.start();
        motorcycle.stop();
        
        Vehicle truck = VehicleFactory.createVehicle("truck");
        truck.start();
        truck.stop();
    }
}
```

### 2. Factory Method Pattern
```java
// 제품 인터페이스
interface Logger {
    void log(String message);
}

// 구체적인 제품들
class FileLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("파일에 로그 기록: " + message);
    }
}

class DatabaseLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("데이터베이스에 로그 기록: " + message);
    }
}

class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("콘솔에 로그 기록: " + message);
    }
}

// 추상 팩토리
abstract class LoggerFactory {
    public abstract Logger createLogger();
    
    public void logMessage(String message) {
        Logger logger = createLogger();
        logger.log(message);
    }
}

// 구체적인 팩토리들
class FileLoggerFactory extends LoggerFactory {
    @Override
    public Logger createLogger() {
        return new FileLogger();
    }
}

class DatabaseLoggerFactory extends LoggerFactory {
    @Override
    public Logger createLogger() {
        return new DatabaseLogger();
    }
}

class ConsoleLoggerFactory extends LoggerFactory {
    @Override
    public Logger createLogger() {
        return new ConsoleLogger();
    }
}

// 클라이언트 코드
public class FactoryMethodExample {
    public static void main(String[] args) {
        LoggerFactory fileLoggerFactory = new FileLoggerFactory();
        fileLoggerFactory.logMessage("파일 로그 테스트");
        
        LoggerFactory dbLoggerFactory = new DatabaseLoggerFactory();
        dbLoggerFactory.logMessage("데이터베이스 로그 테스트");
        
        LoggerFactory consoleLoggerFactory = new ConsoleLoggerFactory();
        consoleLoggerFactory.logMessage("콘솔 로그 테스트");
    }
}
```

## 팩토리 메소드 패턴: 두 가지 구현 방식 비교

### 1. 추상 클래스 기반 분기 (전통적 Factory Method)
```java
// Creator 추상 클래스
abstract class VehicleFactory {
    abstract Vehicle createVehicle();

    public void deliverVehicle() {
        Vehicle vehicle = createVehicle();
        vehicle.drive();
    }
}

// Concrete Creator들
class CarFactory extends VehicleFactory {
    @Override
    Vehicle createVehicle() {
        return new Car();
    }
}

class MotorcycleFactory extends VehicleFactory {
    @Override
    Vehicle createVehicle() {
        return new Motorcycle();
    }
}

// 사용
VehicleFactory carFactory = new CarFactory();
carFactory.deliverVehicle();
```

**장점:**
- ✅ 컴파일 타임 타입 안전성 확보
- ✅ OCP(Open-Closed Principle) 준수 - 새로운 타입 추가 시 기존 코드 수정 불필요
- ✅ DI(Dependency Injection) 친화적
- ✅ IDE 리팩토링 지원 (Rename, Find Usages 등)
- ✅ 각 팩토리가 독립적인 생성 로직과 상태를 가질 수 있음

**단점:**
- ❌ 클래스 수가 많아짐 (타입당 하나의 Factory 클래스)
- ❌ 외부 입력(문자열, 설정 파일 등)으로 객체 생성이 어려움

### 2. 문자열 기반 분기 (Simple Factory 혼합)
```java
class ConcreteProductFactory extends ProductFactory {
    @Override
    public Product createProduct(String type) {
        return switch (type.toLowerCase()) {
            case "electronics" -> new Electronics();
            case "clothing" -> new Clothing();
            case "book" -> new Book();
            default -> throw new IllegalArgumentException("Unknown product type: " + type);
        };
    }
}

// 사용
ProductFactory factory = new ConcreteProductFactory();
Product electronics = factory.orderProduct("electronics");
```

**장점:**
- ✅ 외부 입력(API 요청, 설정 파일)으로 객체 생성 가능
- ✅ 동적 타입 결정 용이
- ✅ 클래스 수가 적음

**단점:**
- ❌ 런타임 오류 가능성 (오타, 잘못된 문자열)
- ❌ OCP 위반 - 새 타입 추가 시 기존 코드 수정 필요
- ❌ 리팩토링 안전성 낮음 (Find & Replace만 가능)
- ❌ 타입 안전성 부족

### 실무에서는 어떤 방식이 더 효과적인가?

**추상 클래스 기반 방식이 더 많이 쓰이고 효과적입니다.**

#### 이유:
1. **타입 안전성**: 컴파일 시점에 오류 발견
2. **확장성**: 새로운 Factory 클래스만 추가하면 됨 (OCP)
3. **유지보수성**: IDE의 리팩토링 도구 활용 가능
4. **Spring/DI 통합**: 자동 의존성 주입 가능

```java
@Service
public class PaymentService {
    private final PaymentFactory paymentFactory;

    // Spring이 자동으로 적절한 Factory 주입
    public PaymentService(PaymentFactory paymentFactory) {
        this.paymentFactory = paymentFactory;
    }
}
```

### 실무 권장: 하이브리드 접근 (Best Practice)

두 가지 장점을 결합한 **Registry Pattern** 활용:

```java
// 1. 추상 클래스로 타입 안전성 확보
public abstract class PaymentFactory {
    public abstract Payment createPayment();

    public Payment processPayment(double amount) {
        Payment payment = createPayment();
        payment.setAmount(amount);
        payment.process();
        return payment;
    }
}

// 2. 각 Factory 구현체
class CreditCardPaymentFactory extends PaymentFactory {
    @Override
    public Payment createPayment() {
        return new CreditCardPayment();
    }
}

class PayPalPaymentFactory extends PaymentFactory {
    @Override
    public Payment createPayment() {
        return new PayPalPayment();
    }
}

class BankTransferPaymentFactory extends PaymentFactory {
    @Override
    public Payment createPayment() {
        return new BankTransferPayment();
    }
}

// 3. Registry로 문자열 매핑 (외부 입력 처리용)
public class PaymentFactoryRegistry {
    private static final Map<String, Supplier<PaymentFactory>> FACTORIES = Map.of(
        "credit-card", CreditCardPaymentFactory::new,
        "paypal", PayPalPaymentFactory::new,
        "bank-transfer", BankTransferPaymentFactory::new
    );

    public static PaymentFactory getFactory(String type) {
        Supplier<PaymentFactory> supplier = FACTORIES.get(type);
        if (supplier == null) {
            throw new IllegalArgumentException("Unknown payment type: " + type);
        }
        return supplier.get();
    }

    // 검증 메서드 추가
    public static boolean isSupported(String type) {
        return FACTORIES.containsKey(type);
    }

    // 지원 타입 목록 조회
    public static Set<String> getSupportedTypes() {
        return FACTORIES.keySet();
    }
}

// 4. 사용 예시
public class PaymentController {
    // 타입 안전하게 사용 (내부 로직)
    public void processInternalPayment() {
        PaymentFactory factory = new CreditCardPaymentFactory();
        Payment payment = factory.processPayment(100.0);
    }

    // 외부 입력 처리 (API 요청 등)
    public Payment processExternalPayment(String paymentType, double amount) {
        // 입력 검증
        if (!PaymentFactoryRegistry.isSupported(paymentType)) {
            throw new IllegalArgumentException(
                "Unsupported payment type. Supported types: " +
                PaymentFactoryRegistry.getSupportedTypes()
            );
        }

        PaymentFactory factory = PaymentFactoryRegistry.getFactory(paymentType);
        return factory.processPayment(amount);
    }
}
```

### Spring Framework에서의 실제 활용

Spring은 추상 클래스/인터페이스 기반을 선호하며, 자동으로 Registry 역할을 해줍니다:

```java
@Component("creditCard")
class CreditCardPaymentFactory extends PaymentFactory { ... }

@Component("paypal")
class PayPalPaymentFactory extends PaymentFactory { ... }

@Service
public class PaymentService {
    // 모든 PaymentFactory 구현체를 Map으로 주입
    private final Map<String, PaymentFactory> factoryMap;

    @Autowired
    public PaymentService(Map<String, PaymentFactory> factoryMap) {
        this.factoryMap = factoryMap;
    }

    public Payment createPayment(String type) {
        PaymentFactory factory = factoryMap.get(type);
        if (factory == null) {
            throw new IllegalArgumentException("Unknown payment type: " + type);
        }
        return factory.createPayment();
    }
}
```

### Java 17+ Sealed Classes 활용 (최신 접근법)

```java
// 타입 안전성을 더욱 강화
public sealed interface PaymentFactory
    permits CreditCardPaymentFactory, PayPalPaymentFactory, BankTransferPaymentFactory {
    Payment createPayment();
}

final class CreditCardPaymentFactory implements PaymentFactory {
    @Override
    public Payment createPayment() {
        return new CreditCardPayment();
    }
}

// 컴파일러가 모든 타입을 알고 있어 exhaustiveness 체크 가능
public Payment processPayment(PaymentFactory factory) {
    return switch (factory) {
        case CreditCardPaymentFactory f -> f.createPayment();
        case PayPalPaymentFactory f -> f.createPayment();
        case BankTransferPaymentFactory f -> f.createPayment();
        // default 불필요 - 컴파일러가 모든 케이스를 확인
    };
}
```

## 면접 답변 포인트

### Q: 팩토리 메소드 패턴에서 추상 클래스 기반과 문자열 기반 중 어떤 것이 더 효과적인가?

**답변:**

"**추상 클래스 기반 방식이 더 효과적이고 실무에서 많이 사용됩니다.**

주요 이유는:

1. **컴파일 타임 타입 안전성** - 런타임 오류를 컴파일 시점에 발견
2. **OCP(Open-Closed Principle) 준수** - 새로운 타입 추가 시 기존 코드 수정 불필요
3. **DI Container 통합** - Spring 등의 프레임워크와 자연스럽게 통합
4. **리팩토링 안전성** - IDE의 자동 리팩토링 도구 활용 가능

다만, **외부 입력(API 요청, 설정 파일)을 처리해야 하는 경우**에는 문자열 기반이 필요합니다.

이런 경우 **Registry Pattern을 활용한 하이브리드 접근법**을 사용합니다:
- 내부적으로는 추상 클래스 기반으로 타입 안전성 확보
- Registry 클래스가 문자열을 적절한 Factory 인스턴스로 매핑
- 이를 통해 타입 안전성과 유연성을 모두 확보

Spring Framework도 이와 유사하게 Map<String, BeanType>으로 Bean 이름과 구현체를 자동 매핑해줍니다."

### Q: Registry Pattern의 장점은?

**답변:**

"Registry Pattern은 다음과 같은 장점이 있습니다:

1. **타입 안전성 유지**: Factory 구현체는 여전히 타입 안전
2. **중앙화된 관리**: 모든 Factory 타입이 한 곳에서 관리됨
3. **검증 로직 추가 가능**: `isSupported()`, `getSupportedTypes()` 등
4. **확장 용이**: Map에 항목만 추가하면 됨
5. **테스트 용이**: Mock Factory를 쉽게 등록 가능

특히 외부 API를 제공하거나 플러그인 시스템을 구축할 때 유용합니다."

## Spring에서의 활용
스프링에서는 `BeanFactory`와 `ApplicationContext`가 팩토리 패턴을 구현한 대표적인 예입니다. 설정에 따라 다양한 빈 객체를 생성하고 관리합니다.
