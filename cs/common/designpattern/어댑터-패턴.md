# 어댑터 패턴 (Adapter Pattern)

## 개념
어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스들이 함께 동작할 수 있도록 중간에서 인터페이스를 변환해주는 구조 패턴입니다. 기존 클래스의 인터페이스를 다른 인터페이스로 변환하여 클라이언트가 기대하는 형태로 사용할 수 있게 해줍니다.

## 언제 사용하면 효과적인가?
- 기존 클래스를 수정하지 않고 새로운 인터페이스와 호환되도록 하고 싶을 때
- 서드파티 라이브러리나 레거시 코드를 새로운 시스템에 통합할 때
- 인터페이스가 다른 여러 클래스를 동일한 방식으로 사용하고 싶을 때
- 외부 API나 데이터 소스의 인터페이스를 내부 시스템에 맞게 변환할 때

## 장점
- **코드 재사용성**: 기존 코드를 수정하지 않고 재사용 가능
- **관심사의 분리**: 인터페이스 변환 로직을 별도로 분리
- **개방-폐쇄 원칙**: 기존 코드는 수정하지 않고 새로운 기능 추가
- **유연성**: 다양한 외부 시스템과의 통합이 용이

## 주의해야 할 점
- 코드 복잡성 증가 (추가적인 래퍼 클래스 필요)
- 런타임 오버헤드 발생 가능
- 어댑터가 너무 많아지면 시스템이 복잡해질 수 있음

## 자바 예시 코드

### 1. Object Adapter Pattern (구성 방식)
```java
import java.util.*;

// 클라이언트가 기대하는 인터페이스
interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 기존의 호환되지 않는 인터페이스들
interface AdvancedMediaPlayer {
    void playVlc(String fileName);
    void playMp4(String fileName);
}

// 기존 VLC 플레이어 (수정할 수 없는 외부 라이브러리)
class VlcPlayer implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        System.out.println("VLC로 " + fileName + " 재생 중");
    }
    
    @Override
    public void playMp4(String fileName) {
        // VLC는 mp4를 지원하지 않음
    }
}

// 기존 MP4 플레이어 (수정할 수 없는 외부 라이브러리)
class Mp4Player implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        // Mp4Player는 vlc를 지원하지 않음
    }
    
    @Override
    public void playMp4(String fileName) {
        System.out.println("MP4 플레이어로 " + fileName + " 재생 중");
    }
}

// 어댑터 클래스
class MediaAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedMusicPlayer;
    
    public MediaAdapter(String audioType) {
        switch (audioType.toLowerCase()) {
            case "vlc":
                advancedMusicPlayer = new VlcPlayer();
                break;
            case "mp4":
                advancedMusicPlayer = new Mp4Player();
                break;
            default:
                throw new IllegalArgumentException("지원하지 않는 오디오 타입: " + audioType);
        }
    }
    
    @Override
    public void play(String audioType, String fileName) {
        switch (audioType.toLowerCase()) {
            case "vlc":
                advancedMusicPlayer.playVlc(fileName);
                break;
            case "mp4":
                advancedMusicPlayer.playMp4(fileName);
                break;
        }
    }
}

// 기본 오디오 플레이어
class AudioPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;
    
    @Override
    public void play(String audioType, String fileName) {
        // 기본 지원 포맷
        if ("mp3".equalsIgnoreCase(audioType)) {
            System.out.println("기본 MP3 플레이어로 " + fileName + " 재생 중");
        }
        // 어댑터를 통한 지원 포맷
        else if ("vlc".equalsIgnoreCase(audioType) || "mp4".equalsIgnoreCase(audioType)) {
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("지원하지 않는 미디어 포맷: " + audioType);
        }
    }
}

// 클라이언트 코드
public class ObjectAdapterExample {
    public static void main(String[] args) {
        AudioPlayer audioPlayer = new AudioPlayer();
        
        audioPlayer.play("mp3", "song.mp3");
        audioPlayer.play("vlc", "movie.vlc");
        audioPlayer.play("mp4", "video.mp4");
        audioPlayer.play("avi", "unsupported.avi");
    }
}
```