# 파사드 패턴

## 개념
복잡한 서브시스템들을 하나의 간단한 인터페이스로 묶어 제공하는 패턴.

## 실무 사용 예시

### 1. 주문 처리 시스템
```java
// 복잡한 내부 시스템들
class PaymentService { void processPayment() {...} }
class InventoryService { void checkStock() {...} }
class ShippingService { void createShipment() {...} }
class NotificationService { void sendEmail() {...} }

// 파사드 - 클라이언트는 이것만 호출
@Service
public class OrderFacade {
    public void placeOrder(Order order) {
        inventoryService.checkStock(order);
        paymentService.processPayment(order);
        shippingService.createShipment(order);
        notificationService.sendEmail(order);
    }
}
```

### 2. 외부 API 통합
```java
// 복잡한 외부 API들을 하나로 묶음
@Service
public class PaymentFacade {
    private final TossPaymentClient tossPayment;
    private final KakaoPayClient kakaoPayment;
    private final NaverPayClient naverPayment;

    public PaymentResult pay(PaymentRequest request) {
        // 복잡한 분기 로직을 내부에 숨김
        switch(request.getMethod()) {
            case TOSS: return tossPayment.charge(request);
            case KAKAO: return kakaoPayment.pay(request);
            case NAVER: return naverPayment.process(request);
        }
    }
}
```

### 3. 레거시 시스템 감싸기
```java
// 복잡한 레거시 코드를 깔끔한 인터페이스로 제공
@Service
public class LegacyUserFacade {
    private final OldUserDAO oldUserDAO;
    private final OldAuthSystem oldAuthSystem;

    public User getUser(Long id) {
        // 레거시 코드의 복잡성을 숨김
        OldUser oldUser = oldUserDAO.findById(id);
        Session session = oldAuthSystem.getSession();
        return convertToNewUser(oldUser, session);
    }
}
```

## 언제 사용하면 효과적인가?

1. **복잡한 라이브러리/API를 간단하게 쓰고 싶을 때**
   - 외부 결제 시스템(토스, 카카오페이 등) 통합
   - AWS SDK 같은 복잡한 클라우드 API 래핑

2. **여러 서비스를 조합해서 하나의 비즈니스 로직을 만들 때**
   - 주문 처리 = 재고 확인 + 결제 + 배송 + 알림
   - 회원가입 = 유효성 검증 + DB 저장 + 이메일 발송 + 쿠폰 발급

3. **레거시 코드를 감싸서 점진적으로 개선할 때**
   - 기존 시스템은 그대로 두고 새로운 인터페이스만 제공
   - 리팩토링 시 클라이언트 코드 변경 최소화

4. **클라이언트와 서브시스템 간 의존성을 줄이고 싶을 때**
   - 내부 구조 변경해도 파사드만 수정하면 됨

## 장점

1. **코드 가독성**: 클라이언트 코드가 단순해짐
2. **낮은 결합도**: 서브시스템 변경이 클라이언트에 영향 최소화
3. **테스트 용이**: 파사드만 Mock으로 대체 가능
4. **점진적 리팩토링**: 기존 코드 변경 없이 새 인터페이스 제공

## 주의해야 할 점

### 1. 파사드가 God Object가 되지 않도록 주의
```java
// 나쁜 예 - 너무 많은 책임
public class SystemFacade {
    void placeOrder() {}
    void cancelOrder() {}
    void processPayment() {}
    void manageInventory() {}
    void sendNotification() {}
    void generateReport() {}  // 무분별하게 추가하면 안됨
}

// 좋은 예 - 관련 있는 기능만 묶음
public class OrderFacade { /* 주문 관련만 */ }
public class PaymentFacade { /* 결제 관련만 */ }
```

### 2. 트랜잭션 처리 주의
```java
@Service
public class OrderFacade {
    @Transactional  // 여기에 걸어야 함
    public void placeOrder(Order order) {
        inventoryService.checkStock(order);      // 각각의 서비스는
        paymentService.processPayment(order);    // 트랜잭션 없음
        shippingService.createShipment(order);
    }
}
```

### 3. 에러 처리 일관성
```java
public class PaymentFacade {
    public PaymentResult pay(PaymentRequest request) {
        try {
            // 각기 다른 예외를 통일된 예외로 변환
            return paymentClient.charge(request);
        } catch (TossException | KakaoException e) {
            throw new PaymentFailedException(e);  // 통일된 예외
        }
    }
}
```

### 4. 너무 얇은 파사드는 무의미
```java
// 나쁜 예 - 단순 위임만 하면 의미 없음
public class UserFacade {
    public User getUser(Long id) {
        return userService.getUser(id);  // 그냥 직접 호출하는게 나음
    }
}

// 좋은 예 - 실제로 복잡성을 숨김
public class UserFacade {
    public UserProfile getUserProfile(Long id) {
        User user = userService.getUser(id);
        List<Order> orders = orderService.getUserOrders(id);
        Point point = pointService.getUserPoint(id);
        return UserProfile.of(user, orders, point);  // 조합된 데이터 제공
    }
}
```

## 실무 팁

1. **Spring에서는 `@Service`로 파사드 구현**
   - 컨트롤러는 파사드만 호출
   - 파사드가 여러 서비스 조합

2. **파사드 네이밍**: `XxxFacade` 보다는 비즈니스 의미 있는 이름
   - `OrderProcessingService` (O)
   - `PaymentGateway` (O)
   - `SystemFacade` (X - 너무 추상적)

3. **과도한 사용 지양**
   - 모든 서비스 호출마다 파사드 만들 필요 없음
   - 실제로 복잡한 로직을 단순화할 때만 사용
