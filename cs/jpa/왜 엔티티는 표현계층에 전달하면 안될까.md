# 왜 엔티티는 표현계층에 전달하면 안될까

## 주요 이유 3가지


**문제점:**
- 엔티티가 표현계층(Controller, View)까지 전달되면 영속성 컨텍스트가 닫힌 상태에서 지연 로딩된 연관 엔티티에 `LazyInitializationException` 발생
- OSIV(Open Session In View)로 커넥션을 유지해야하기 때문에 성능에 악영향
- 'N + 1' 으로 인한 데이터베이스 부하 증가

**예시:**
```java
// Controller에서 엔티티를 직접 반환
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id); // Entity 직접 반환
    }
    
    // View에서 연관 엔티티 접근 시
    user.getOrders().size() // LazyInitializationException 발생 가능
```

**해결 방안:**
- DTO(Data Transfer Object)를 사용하여 필요한 데이터만 명시적으로 조회
- Service 계층에서 필요한 데이터를 모두 로딩하여 DTO로 변환

### 2. 순환 참조(Circular Reference)로 인한 무한 루프

**문제점:**
- 양방향 연관관계를 가진 엔티티를 JSON으로 직렬화할 때 무한 루프 발생
- `StackOverflowError` 또는 직렬화 오류 발생
- `@JsonIgnore`, `@JsonManagedReference` 등의 어노테이션으로 회피하려 해도 엔티티가 JSON 직렬화에 종속되는 문제

**예시:**
```java
@Entity
public class User {
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}

@Entity
public class Order {
    @ManyToOne
    private User user;
}

// JSON 직렬화 시 User -> Order -> User -> Order ... 무한 반복
```

**해결 방안:**
- DTO를 사용하여 필요한 데이터만 선택적으로 포함
- 단방향 데이터 구조로 설계된 응답 객체 사용

### 3. 엔티티 변경에 따른 API 스펙 불안정성

**문제점:**
- 엔티티는 데이터베이스 스키마와 밀접하게 연관되어 있어 자주 변경될 수 있음
- 엔티티 필드 추가/삭제/변경 시 API 응답 스펙이 함께 변경되어 클라이언트에 영향
- 테이블 구조와 API 응답 구조가 강하게 결합되어 유연성 저하
- 내부 도메인 정보(비밀번호, 내부 ID 등)가 의도치 않게 노출될 위험

**예시:**
```java
@Entity
public class User {
    private Long id;
    private String username;
    private String password; // 민감 정보
    private String internalCode; // 내부 코드

    // 엔티티에 필드 추가 시 API 응답에 자동으로 포함됨
    private LocalDateTime lastModifiedAt;
}

// 엔티티 직접 반환 시 모든 필드가 노출됨
```

**해결 방안:**
- API 버전별 DTO를 사용하여 응답 스펙 명시적 관리
- 필요한 필드만 포함된 DTO로 엔티티와 API 스펙 분리

---

## 추가로 알아야 할 것들

### 1. DTO 변환 시점과 계층별 책임

**Service 계층에서 DTO 변환:**
```java
@Service
@Transactional(readOnly = true)
public class UserService {
    public UserResponse findUserById(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException());

        // Service 계층에서 DTO 변환
        return UserResponse.from(user);
    }
}
```

**Controller 계층:**
```java
@RestController
@RequiredArgsConstructor
public class UserController {
    private final UserService userService;

    @GetMapping("/users/{id}")
    public UserResponse getUser(@PathVariable Long id) {
        return userService.findUserById(id); // 이미 DTO
    }
}
```

**핵심:**
- Service 계층은 비즈니스 로직 처리 후 DTO 반환
- Controller는 HTTP 요청/응답 처리에만 집중
- 엔티티는 Repository와 Service 내부에서만 사용

### 2. DTO 패턴 종류

**Request DTO vs Response DTO:**
```java
// 요청 DTO - 유효성 검증 포함
public record UserCreateRequest(
    @NotBlank String username,
    @Email String email,
    @Size(min = 8) String password
) {}

// 응답 DTO - 표현 계층에 필요한 데이터만
public record UserResponse(
    Long id,
    String username,
    String email,
    LocalDateTime createdAt
) {
    public static UserResponse from(User user) {
        return new UserResponse(
            user.getId(),
            user.getUsername(),
            user.getEmail(),
            user.getCreatedAt()
        );
    }
}
```

### 3. DTO 변환 방법

**정적 팩토리 메서드 (권장):**
```java
public record UserResponse(...) {
    public static UserResponse from(User user) {
        return new UserResponse(...);
    }

    // 연관 엔티티 포함
    public static UserResponse fromWithOrders(User user) {
        return new UserResponse(
            user.getId(),
            user.getUsername(),
            user.getOrders().stream()
                .map(OrderResponse::from)
                .toList()
        );
    }
}
```

### 3. OSIV (Open Session In View) 설정과 트레이드오프

**OSIV 활성화 시 (기본값: true):**
```yaml
spring:
  jpa:
    open-in-view: true # 기본값
```

**장점:**
- 표현 계층에서 지연 로딩 사용 가능
- LazyInitializationException 방지

**단점:**
- 데이터베이스 커넥션을 오래 점유하여 성능 저하
- 표현 계층에서 의도치 않은 쿼리 실행 가능
- 트랜잭션 범위가 모호해짐

**권장 설정:**
```yaml
spring:
  jpa:
    open-in-view: false # 명시적으로 비활성화 권장
```

---

## 면접 대비 핵심 포인트

### 질문: "엔티티를 Controller에서 직접 반환하면 안 되는 이유는?"

**답변 구성:**
1. **지연 로딩 문제**: 영속성 컨텍스트 범위를 벗어나면 LazyInitializationException 발생
2. **순환 참조**: 양방향 연관관계 시 JSON 직렬화 무한 루프
3. **API 스펙 불안정**: 엔티티 변경이 API 응답에 직접 영향
4. **보안**: 민감 정보 의도치 않은 노출 위험

### 후속 질문 대비

**Q: "그럼 OSIV를 켜면 되지 않나요?"**
- OSIV는 문제를 숨기는 것일 뿐 근본 해결이 아님
- 커넥션 점유 시간 증가로 성능 저하
- 명시적인 DTO 변환이 더 안전하고 예측 가능

**Q: "DTO를 사용하면 코드가 많아지는데?"**
- Java 14+ Record 사용으로 보일러플레이트 최소화
- Object Mapper 등 변환 코드 자동 생성

**Q: "성능상 DTO 변환 오버헤드는?"**
- 객체 생성 비용은 미미함 (나노초 단위)
- QueryDSL Projections로 DTO 직접 조회 시 엔티티보다 빠름
- 지연 로딩 문제로 인한 N+1 쿼리 방지가 더 큰 성능 개선
