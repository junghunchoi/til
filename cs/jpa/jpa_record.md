**JPA 엔티티로 Records를 사용할 수 없는 주요 제약사항**
기본 생성자(No-args Constructor) 요구사항:

JPA 프로바이더(예: Hibernate)는 데이터베이스에서 데이터를 로드할 때 리플렉션(Reflection)을 사용하여 엔티티 객체를 인스턴스화합니다. 이를 위해서는 인수 없는(no-args) 기본 생성자가 필요합니다.

레코드는 모든 컴포넌트(필드)를 인자로 받는 정규 생성자(canonical constructor)만을 자동으로 생성하며, 기본 생성자를 제공하지 않습니다. (명시적으로 추가할 수는 있지만, 이는 레코드의 본래 목적과 간결성을 해칩니다.)

불변성(Immutability):

레코드는 본질적으로 불변(immutable)입니다. 즉, 일단 생성되면 필드 값을 변경할 수 없습니다.

JPA 엔티티는 데이터베이스의 변경 사항을 추적하고, 영속성 컨텍스트(Persistence Context) 내에서 상태를 변경하며, 변경된 내용을 다시 데이터베이스에 반영(Dirty Checking)해야 합니다. 이를 위해서는 가변성(mutability)이 필수적이며, 일반적으로 필드에 대한 세터(setter) 메소드를 가집니다.

레코드는 세터 메소드를 제공하지 않습니다.

지연 로딩(Lazy Loading) 문제:

JPA는 연관 관계 매핑 시 성능 최적화를 위해 지연 로딩(Lazy Loading) 기능을 제공합니다. 이는 실제 데이터가 필요할 때까지 관련된 엔티티를 로드하지 않는 방식입니다.

지연 로딩은 엔티티 객체의 프록시(Proxy)를 생성하여 동작하는데, 프록시는 원본 엔티티 클래스를 상속받아 런타임에 생성됩니다.

레코드는 final 클래스이므로 상속될 수 없기 때문에 JPA 프로바이더가 프록시를 생성할 수 없습니다. 따라서 지연 로딩이 제대로 작동하지 않거나 사용할 수 없습니다.

엔티티 라이프사이클 콜백(Lifecycle Callbacks):

JPA 엔티티는 @PrePersist, @PostLoad와 같은 라이프사이클 콜백 메소드를 통해 특정 시점에 비즈니스 로직을 수행할 수 있습니다.

레코드는 이러한 콜백 메커니즘을 지원하지 않습니다.