# 마이크로서비스 환경에서의 데이터 일관성 유지 전략

## 개요
이 프로젝트는 마이크로서비스 아키텍처에서 데이터 일관성을 유지하기 위한 전략을 보여주는 예제입니다. 특히 주문 서비스와 재고 서비스 간의 데이터 일관성을 보장하기 위해 Saga 패턴과 이벤트 기반 아키텍처를 구현했습니다.

## 문제 상황
마이크로서비스 아키텍처에서는 각 서비스가 자체 데이터베이스를 가지고 있습니다. 이로 인해 여러 서비스에 걸친 트랜잭션 처리가 어려워집니다. 예를 들어, 주문이 생성될 때 재고를 감소시키는 작업이 필요하지만, 이 두 작업은 서로 다른 서비스와 데이터베이스에서 이루어집니다.

## 해결 전략
이 문제를 해결하기 위해 다음과 같은 전략을 적용했습니다:

### 1. Saga 패턴
Saga 패턴은 분산 트랜잭션을 관리하기 위한 패턴으로, 각 서비스의 로컬 트랜잭션과 보상 트랜잭션을 이용해 데이터 일관성을 유지합니다.

- **코레오그래피 방식(Choreography)**: 이벤트를 발행하고 구독하는 방식으로 서비스 간 통신
- **오케스트레이션 방식(Orchestration)**: 중앙 조정자가 트랜잭션 흐름을 관리

### 2. 이벤트 소싱(Event Sourcing)
상태 변경을 이벤트로 저장하여 시스템의 상태를 재구성할 수 있게 합니다. 이를 통해 서비스 간의 느슨한 결합을 유지하면서 데이터 일관성을 확보할 수 있습니다.

### 3. 최종 일관성(Eventual Consistency)
강한 일관성(Strong Consistency) 대신 최종 일관성을 허용함으로써, 시스템의 가용성과 성능을 향상시킵니다.

## 구현 예제
이 프로젝트에서는 주문 서비스와 재고 서비스 간의 데이터 일관성을 유지하기 위한 Saga 패턴의 코레오그래피 방식을 구현했습니다. 

1. **주문 서비스**: 주문을 생성하고 주문 생성 이벤트를 발행합니다.
2. **재고 서비스**: 주문 생성 이벤트를 수신하여 재고를 감소시킵니다.
3. **보상 트랜잭션**: 재고 감소에 실패할 경우, 주문이 취소되고 취소 이벤트가 발행됩니다.

## 기술 스택
- Spring Boot
- Spring Cloud Stream
- Kafka
- JPA/Hibernate
- H2 Database (개발용)

## 실행 방법
1. Kafka 서버 실행
2. 주문 서비스 실행: `./gradlew :order-service:bootRun`
3. 재고 서비스 실행: `./gradlew :inventory-service:bootRun`
4. API 테스트: Postman이나 curl을 이용하여 주문 API 호출

## 적용 경험 및 교훈
실제 프로젝트에서 이러한 패턴을 적용하면서 얻은 교훈:

1. **트랜잭션 설계의 중요성**: 분산 시스템에서는 트랜잭션 설계가 매우 중요합니다. 모든 가능한 실패 시나리오를 고려해야 합니다.
2. **모니터링 및 로깅**: 분산 트랜잭션의 상태를 추적하기 위한 효과적인 모니터링 및 로깅 시스템이 필요합니다.
3. **멱등성(Idempotency)**: 같은 요청이 여러 번 처리되어도 결과가 동일하도록 서비스를 설계해야 합니다.
4. **재시도 메커니즘**: 일시적인 장애를 처리하기 위한 재시도 메커니즘이 필요합니다.

## 결론
마이크로서비스 아키텍처에서 데이터 일관성을 유지하는 것은 도전적인 과제입니다. Saga 패턴, 이벤트 소싱, 그리고 최종 일관성과 같은 전략을 통해 이 문제를 효과적으로 해결할 수 있습니다. 이러한 패턴을 적용할 때는 시스템의 특성과 요구사항을 고려하여 적절한 전략을 선택해야 합니다.
